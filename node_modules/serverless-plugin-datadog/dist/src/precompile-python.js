"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.precompilePython = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
function precompilePython(serverless) {
    serverless.cli.log('Precompiling Python files');
    let tempDirName = 'datadog';
    let slsDir = serverless.processedInput.options.package || '.serverless';
    let tempDir = path.resolve(slsDir, tempDirName);
    for (const file of lsDirFiles(slsDir, false)) {
        if (file.endsWith('.zip')) {
            preCompilePackage(serverless.service.provider.runtime, tempDir, file);
        }
    }
}
exports.precompilePython = precompilePython;
function preCompilePackage(python, tempDir, zipFile) {
    (0, child_process_1.spawnSync)('unzip', ['-d', tempDir, zipFile]);
    precompile(python, tempDir);
    replacePyFiles(tempDir);
    (0, child_process_1.spawnSync)('rm', [zipFile]);
    (0, child_process_1.execSync)(`cd ${tempDir} && zip -r ${zipFile} .`);
    (0, child_process_1.spawnSync)('rm', ['-r', tempDir]);
}
function precompile(python, dir) {
    // TODO: run precompile in docker container
    //spawnSync('python', ['-m', 'compileall', '-b', dir]);
    console.log("----------------------------------------");
    console.log("python: ", python);
    console.log("----------------------------------------");
    let image = python.replace('python3', 'python:3');
    (0, child_process_1.spawnSync)('docker', ['run', '-v', `${dir}:/mnt`, image, 'python', '-m', 'compileall', '-b', '/mnt']);
}
function replacePyFiles(dir) {
    for (const file of lsDirFiles(dir)) {
        if (file.endsWith('.pyc')) {
            let pyFile = file.replace('.pyc', '.py');
            (0, child_process_1.spawnSync)('rm', [pyFile]);
        }
    }
}
function* lsDirFiles(dir, recursive = true) {
    for (const dirent of fs.readdirSync(dir, { withFileTypes: true })) {
        const res = path.resolve(dir, dirent.name);
        if (recursive && dirent.isDirectory()) {
            yield* lsDirFiles(res, recursive);
        }
        else {
            yield res;
        }
    }
}
//# sourceMappingURL=precompile-python.js.map