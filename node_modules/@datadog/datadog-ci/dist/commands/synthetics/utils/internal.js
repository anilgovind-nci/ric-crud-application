"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAndParseOverrides = exports.parseOverrideValue = exports.toStringMap = exports.toExecutionRule = exports.toNumber = exports.toBoolean = exports.getResultIdOrLinkedResultId = exports.isMobileTestWithOverride = exports.isResultInBatchSkippedBySelectiveRerun = exports.isTimedOutRetry = exports.isNonFinalResult = exports.hasDefinedResult = exports.isBaseResult = exports.hasResultPassed = exports.getOverriddenExecutionRule = void 0;
const interfaces_1 = require("../interfaces");
const public_1 = require("./public");
const levenshtein = require('fast-levenshtein');
const getOverriddenExecutionRule = (test, testOverrides) => {
    var _a, _b;
    if (testOverrides === null || testOverrides === void 0 ? void 0 : testOverrides.executionRule) {
        return (0, public_1.getStrictestExecutionRule)(testOverrides.executionRule, (_b = (_a = test === null || test === void 0 ? void 0 : test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule);
    }
};
exports.getOverriddenExecutionRule = getOverriddenExecutionRule;
const hasResultPassed = (result, isUnhealthy, hasTimedOut, options) => {
    if (isUnhealthy && !options.failOnCriticalErrors) {
        return true;
    }
    if (hasTimedOut && !options.failOnTimeout) {
        return true;
    }
    return result.status === 'passed';
};
exports.hasResultPassed = hasResultPassed;
/**
 * Whether the result is of type {@link BaseResult}, i.e. it wasn't skipped.
 */
const isBaseResult = (result) => {
    return !(0, public_1.isResultSkippedBySelectiveRerun)(result);
};
exports.isBaseResult = isBaseResult;
/**
 * Whether the result has a defined {@link BaseResult.result} property.
 *
 * This property would be undefined if the server result isn't available when polling for it,
 * which is a known latency issue. We call such result an incomplete result.
 */
const hasDefinedResult = (result) => {
    return (0, exports.isBaseResult)(result) && result.result !== undefined;
};
exports.hasDefinedResult = hasDefinedResult;
/**
 * When the test is configured to be retried and the first attempt fails, `retries` is set to `0`
 * and the result is kept `in_progress` until the final result is received.
 */
const isNonFinalResult = (result) => {
    return result.status === 'in_progress' && Number.isInteger(result.retries);
};
exports.isNonFinalResult = isNonFinalResult;
const isTimedOutRetry = (retries, maxRetries, timedOut) => {
    return !!timedOut && (retries !== null && retries !== void 0 ? retries : 0) < (maxRetries !== null && maxRetries !== void 0 ? maxRetries : 0);
};
exports.isTimedOutRetry = isTimedOutRetry;
const isResultInBatchSkippedBySelectiveRerun = (result) => {
    var _a;
    return ((_a = result.selective_rerun) === null || _a === void 0 ? void 0 : _a.decision) === 'skip';
};
exports.isResultInBatchSkippedBySelectiveRerun = isResultInBatchSkippedBySelectiveRerun;
const isMobileTestWithOverride = (item) => 'test' in item && item.test.type === 'mobile' && !!item.test.options && !!item.test.options.mobileApplication;
exports.isMobileTestWithOverride = isMobileTestWithOverride;
const getResultIdOrLinkedResultId = (result) => {
    if ((0, exports.isResultInBatchSkippedBySelectiveRerun)(result)) {
        return result.selective_rerun.linked_result_id;
    }
    return result.result_id;
};
exports.getResultIdOrLinkedResultId = getResultIdOrLinkedResultId;
const toBoolean = (env) => {
    if (env === undefined) {
        return undefined;
    }
    if (env.toLowerCase() === 'true' || env === '1') {
        return true;
    }
    if (env.toLowerCase() === 'false' || env === '0') {
        return false;
    }
    return undefined;
};
exports.toBoolean = toBoolean;
const toNumber = (env) => {
    if (env === undefined || env.trim() === '') {
        return undefined;
    }
    const number = Number(env);
    if (isNaN(number)) {
        return undefined;
    }
    return number;
};
exports.toNumber = toNumber;
const toExecutionRule = (env) => {
    if (env === undefined) {
        return undefined;
    }
    const enumValues = Object.values(interfaces_1.ExecutionRule);
    if (enumValues.includes(env.toLowerCase())) {
        return env.toLowerCase();
    }
    return undefined;
};
exports.toExecutionRule = toExecutionRule;
const toStringMap = (env) => {
    if (env === undefined) {
        return undefined;
    }
    const cleanedEnv = env.replace(/'/g, '"');
    try {
        const parsed = JSON.parse(cleanedEnv);
        // eslint-disable-next-line no-null/no-null
        if (typeof parsed === 'object' && parsed !== null) {
            for (const key in parsed) {
                if (typeof parsed[key] !== 'string') {
                    return undefined;
                }
            }
            return parsed;
        }
    }
    catch (error) {
        return undefined;
    }
};
exports.toStringMap = toStringMap;
const allOverrideKeys = [
    'cookies',
    'setCookies',
    'retry',
    'basicAuth',
    'allowInsecureCertificates',
    'body',
    'bodyType',
    'defaultStepTimeout',
    'deviceIds',
    'executionRule',
    'followRedirects',
    'headers',
    'locations',
    'pollingTimeout',
    'resourceUrlSubstitutionRegexes',
    'startUrl',
    'startUrlSubstitutionRegex',
    'testTimeout',
    'variables',
];
const parseOverrideValue = (value, type) => {
    switch (type) {
        case 'boolean':
            const parsedBoolean = (0, exports.toBoolean)(value);
            if (parsedBoolean !== undefined) {
                return parsedBoolean;
            }
            throw new Error(`Invalid boolean value: ${value}`);
        case 'number':
            const parsedNumber = (0, exports.toNumber)(value);
            if (parsedNumber !== undefined) {
                return parsedNumber;
            }
            throw new Error(`Invalid number value: ${value}`);
        case 'string':
            return value.replace(/\\n/g, '\n').trim();
        case 'string[]':
            return value.split(';').map((item) => item.trim());
        case 'ExecutionRule':
            const parsedExecutionRule = (0, exports.toExecutionRule)(value);
            if (parsedExecutionRule !== undefined) {
                return parsedExecutionRule;
            }
            throw new Error(`Invalid ExecutionRule value: ${value}`);
        default:
            throw new Error(`Unknown type: ${type}`);
    }
};
exports.parseOverrideValue = parseOverrideValue;
const validateAndParseOverrides = (overrides) => {
    if (!overrides) {
        return {};
    }
    const parsedOverrides = overrides.reduce((acc, override) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const match = (_a = override.match(/^(.*?)=(.*)$/s)) !== null && _a !== void 0 ? _a : []; // split key and value at first equal sign
        const rawKey = (_b = match[1]) !== null && _b !== void 0 ? _b : '';
        const value = (_c = match[2]) !== null && _c !== void 0 ? _c : '';
        const key = rawKey.split('.')[0];
        const subKey = rawKey.split('.')[1];
        switch (key) {
            // Convert to number
            case 'defaultStepTimeout':
            // TODO SYNTH-12989: Clean up `pollingTimeout` in favor of `batchTimeout`
            case 'pollingTimeout':
            case 'testTimeout':
                acc[key] = (0, exports.parseOverrideValue)(value, 'number');
                break;
            // Convert to boolean
            case 'allowInsecureCertificates':
            case 'followRedirects':
                acc[key] = (0, exports.parseOverrideValue)(value, 'boolean');
                break;
            // Convert to string
            case 'body':
            case 'bodyType':
            case 'startUrl':
            case 'startUrlSubstitutionRegex':
                acc[key] = (0, exports.parseOverrideValue)(value, 'string');
                break;
            // Convert to string[]
            case 'deviceIds':
            case 'locations':
            case 'resourceUrlSubstitutionRegexes':
                acc[key] = (0, exports.parseOverrideValue)(value, 'string[]');
                break;
            // Convert to ExecutionRule
            case 'executionRule':
                acc[key] = (0, exports.parseOverrideValue)(value, 'ExecutionRule');
                break;
            // Convert to RetryConfig
            case 'retry':
                switch (subKey) {
                    case 'count':
                    case 'interval':
                        acc['retry'] = (_d = acc['retry']) !== null && _d !== void 0 ? _d : {};
                        acc['retry'][subKey] = (0, exports.parseOverrideValue)(value, 'number');
                        break;
                    default:
                        throw new Error(`Invalid subkey for ${key}`);
                }
                break;
            // Convert to BasicAuthCredentials
            case 'basicAuth':
                switch (subKey) {
                    case 'username':
                    case 'password':
                        acc['basicAuth'] = (_e = acc['basicAuth']) !== null && _e !== void 0 ? _e : {};
                        acc['basicAuth'][subKey] = (0, exports.parseOverrideValue)(value, 'string');
                        break;
                    default:
                        throw new Error(`Invalid subkey for ${key}`);
                }
                break;
            // Convert to cookies and set-cookies (either a string or an object)
            case 'cookies':
            case 'setCookies':
                acc[key] = (_f = acc[key]) !== null && _f !== void 0 ? _f : {};
                if (subKey) {
                    if (subKey === 'append') {
                        ;
                        acc[key].append = (0, exports.parseOverrideValue)(value, 'boolean');
                    }
                    else {
                        throw new Error(`The path "${key}.${subKey}" is invalid. Did you mean \`--override ${key}=...\`?`);
                    }
                }
                else {
                    ;
                    acc[key].value = (0, exports.parseOverrideValue)(value, 'string');
                }
                break;
            // Convert to StringMap
            case 'headers':
            case 'variables':
                if (subKey) {
                    acc[key] = (_g = acc[key]) !== null && _g !== void 0 ? _g : {};
                    acc[key][subKey] = value;
                }
                else {
                    throw new Error(`No subkey found for ${key}`);
                }
                break;
            default:
                const closestKey = allOverrideKeys.reduce((prev, curr) => levenshtein.get(curr, key) < levenshtein.get(prev, key) ? curr : prev);
                if (levenshtein.get(closestKey, key) > 5) {
                    throw new Error(`Invalid key: ${key}`);
                }
                throw new Error(`Invalid key: ${key}. Did you mean \`${closestKey}\`?`);
        }
        return acc;
    }, {});
    return parsedOverrides;
};
exports.validateAndParseOverrides = validateAndParseOverrides;
//# sourceMappingURL=internal.js.map