"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePayload = void 0;
const console = __importStar(require("console"));
const crypto_1 = __importDefault(require("crypto"));
const tags_1 = require("../../helpers/tags");
const constants_1 = require("./constants");
const language_1 = require("./language");
// Parse a location from the file generated by osv-scanner into a location that can be
// sent to our API.
const parseLocation = (location) => {
    if (!location) {
        return undefined;
    }
    if (!location.file_name ||
        !location.line_start ||
        !location.line_end ||
        !location.column_start ||
        !location.column_end) {
        return undefined;
    }
    if (location.line_end < location.line_start) {
        return undefined;
    }
    if (location.line_end === location.line_start && location.column_end <= location.column_start) {
        return undefined;
    }
    // check location values
    if (location.line_start <= 0 || location.line_end <= 0 || location.column_start <= 0 || location.column_end <= 0) {
        return undefined;
    }
    return {
        file_name: location.file_name,
        start: {
            line: location.line_start,
            col: location.column_start,
        },
        end: {
            line: location.line_end,
            col: location.column_end,
        },
    };
};
// Parse all locations from the OSV scanner. If one fails to be parse, it's set to undefined
const parseLocationsString = (locations) => {
    try {
        const parsed = JSON.parse(locations);
        const res = {
            block: parseLocation(parsed['block']),
            namespace: parseLocation(parsed['namespace']),
            name: parseLocation(parsed['name']),
            version: parseLocation(parsed['version']),
        };
        // if block is not defined, the API fails and we should rather ignore the payload
        if (!res.block) {
            return undefined;
        }
        return res;
    }
    catch (e) {
        console.error(`error when parsing locations: ${e}`);
    }
    return undefined;
};
// Generate the payload we send to the API
// jsonContent is the SBOM file content read from disk
// tags are the list of tags we retrieved
const generatePayload = (jsonContent, tags, service, env) => {
    if (!tags[tags_1.GIT_COMMIT_AUTHOR_EMAIL] ||
        !tags[tags_1.GIT_COMMIT_AUTHOR_NAME] ||
        !tags[tags_1.GIT_COMMIT_COMMITTER_EMAIL] ||
        !tags[tags_1.GIT_COMMIT_COMMITTER_NAME] ||
        !tags[tags_1.GIT_SHA] ||
        !tags[tags_1.GIT_BRANCH] ||
        !tags[tags_1.GIT_REPOSITORY_URL]) {
        return undefined;
    }
    const dependencies = [];
    const files = [];
    const relations = [];
    if (jsonContent) {
        if (jsonContent['components']) {
            for (const component of jsonContent['components']) {
                if (!component['type'] || !component['name']) {
                    continue;
                }
                if (component['type'] === 'library') {
                    const dependency = extractingDependency(component);
                    if (dependency !== undefined) {
                        dependencies.push(dependency);
                    }
                }
                else if (component['type'] === 'file') {
                    files.push(extractingFile(component));
                }
            }
        }
        if (jsonContent['dependencies']) {
            for (const dependency of jsonContent['dependencies']) {
                if (!dependency['ref'] || !dependency['dependsOn']) {
                    continue;
                }
                relations.push(extractingRelations(dependency));
            }
        }
    }
    return {
        id: crypto_1.default.randomUUID(),
        commit: {
            author_name: tags[tags_1.GIT_COMMIT_AUTHOR_NAME],
            author_email: tags[tags_1.GIT_COMMIT_AUTHOR_EMAIL],
            committer_name: tags[tags_1.GIT_COMMIT_COMMITTER_NAME],
            committer_email: tags[tags_1.GIT_COMMIT_COMMITTER_EMAIL],
            sha: tags[tags_1.GIT_SHA],
            branch: tags[tags_1.GIT_BRANCH],
        },
        repository: {
            url: tags[tags_1.GIT_REPOSITORY_URL],
        },
        tags,
        dependencies,
        files,
        relations,
        service,
        env,
    };
};
exports.generatePayload = generatePayload;
const extractingDependency = (component) => {
    var _a;
    const lang = (0, language_1.getLanguageFromComponent)(component);
    if (!lang) {
        return;
    }
    const purl = component['purl'];
    if (!purl) {
        console.error(`cannot find purl for component ${component['name']}`);
        return;
    }
    const locations = [];
    // Extract the unique location strings from the file.
    const locationsStrings = new Set();
    if (component['evidence'] && component['evidence']['occurrences']) {
        for (const occ of component['evidence']['occurrences']) {
            if (occ['location']) {
                const loc = occ['location'];
                if (!locationsStrings.has(loc)) {
                    locationsStrings.add(loc);
                }
            }
        }
    }
    for (const l of locationsStrings) {
        const loc = parseLocationsString(l);
        if (loc) {
            locations.push(loc);
        }
    }
    let packageManager = '';
    let isDirect;
    for (const property of (_a = component['properties']) !== null && _a !== void 0 ? _a : []) {
        if (property['name'] === constants_1.PACKAGE_MANAGER_PROPERTY_KEY) {
            packageManager = property['value'];
        }
        else if (property['name'] === constants_1.IS_DEPENDENCY_DIRECT_PROPERTY_KEY) {
            isDirect = property['value'].toLowerCase() === 'true' ? true : undefined;
        }
    }
    const dependency = {
        name: component['name'],
        group: component['group'] || undefined,
        version: component['version'] || undefined,
        language: lang,
        licenses: [],
        purl,
        locations,
        is_direct: isDirect,
        package_manager: packageManager,
    };
    return dependency;
};
const extractingFile = (component) => {
    var _a;
    let purl;
    for (const property of (_a = component['properties']) !== null && _a !== void 0 ? _a : []) {
        if (property['name'] === constants_1.FILE_PACKAGE_PROPERTY_KEY) {
            purl = property['value'];
        }
    }
    return {
        name: component['name'],
        purl,
    };
};
const extractingRelations = (dependency) => {
    return {
        component_ref: dependency['ref'],
        depends_on: dependency['dependsOn'],
    };
};
//# sourceMappingURL=payload.js.map